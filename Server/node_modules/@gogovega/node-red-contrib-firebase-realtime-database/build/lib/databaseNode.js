"use strict";
/**
 * Copyright 2022-2023 Gauthier Dandele
 *
 * Licensed under the MIT License,
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/MIT.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const app_1 = require("@firebase/app");
const auth_1 = require("@firebase/auth");
const database_1 = require("@firebase/database");
const firebase_admin_1 = __importDefault(require("firebase-admin"));
const database_2 = require("./const/database");
const FirebaseError_1 = require("./const/FirebaseError");
const DatabaseNodeType_1 = require("./types/DatabaseNodeType");
/**
 * FirebaseDatabase Class
 *
 * This class is used to communicate with Google Firebase Realtime Databases.
 *
 * The modules used are `firebase` and `firebase-admin`.
 *
 * The Authentication Methods are:
 * - Anonymous
 * - Email and Password
 * - Private Key (SDK Admin)
 *
 * @param node The `config-node` to associate with this class
 * @returns A FirebaseDatabase Class
 */
class FirebaseDatabase {
    constructor(node) {
        this.node = node;
        /**
         * This property is true if the authentication method used uses the `firebase-admin` module.
         */
        this.admin = this.node.config.authType === "privateKey";
        /**
         * Property called by the `Firebase:log` event. Gets the log in order to make it an error and to update the status of
         * the nodes.
         * @param log The log received
         */
        this.onLog = (log) => {
            if (log.message.includes("URL of your Firebase Realtime Database instance configured correctly")) {
                if (!log.message.includes(this.node.credentials.url))
                    return;
                return this.onError(new app_1.FirebaseError("auth/invalid-database-url", ""));
            }
            if (log.message.includes("app/invalid-credential"))
                return this.onError(new app_1.FirebaseError("auth/invalid-credential", ""));
        };
        node.destroyUnusedConnection = this.destroyUnusedConnection.bind(this);
        node.restoreDestroyedConnection = this.restoreDestroyedConnection.bind(this);
    }
    /**
     * Checks if the Claim keys are authorized.
     * @param claims The additional claims to be added to the token.
     * @returns The token generated.
     */
    checkClaims(claims = {}) {
        if (typeof claims !== "object")
            throw new Error("Additional Claims must be an object!");
        Object.keys(claims || {}).forEach((key) => {
            if (database_2.claimsNotAllowed.includes(key))
                throw new Error(`Claim key '${key}' is not allowed`);
        });
        return Object.entries(claims || {}).reduce((acc, [key, value]) => {
            acc[key] = value.value;
            return acc;
        }, {});
    }
    /**
     * Check if the received JSON content credentials contain the desired elements.
     * @param content The JSON content credentials
     * @returns The JSON content credentials checked
     */
    checkJSONCredential(content) {
        if (!content || typeof content !== "object" || !Object.keys(content).length)
            throw new Error("JSON Content must contain 'projectId', 'clientEmail' and 'privateKey'");
        const cred = content;
        const output = {
            clientEmail: cred["client_email"] || cred["clientEmail"],
            privateKey: cred["private_key"] || cred["privateKey"],
            projectId: cred["project_id"] || cred["projectId"],
        };
        for (const [key, value] of Object.entries(output)) {
            if (!value)
                throw new Error(`JSON Content must contain '${key}'`);
        }
        return output;
    }
    /**
     * Creates a Custom Token with UID and additional Claims generated with the Private Key.
     * @returns The Token created.
     */
    async createCustomToken() {
        const claims = this.checkClaims(this.node.config.claims);
        const content = this.getJSONCredential();
        const app = firebase_admin_1.default.initializeApp({
            credential: firebase_admin_1.default.credential.cert(content),
            databaseURL: this.node.credentials.url,
        });
        const token = await firebase_admin_1.default.auth(app).createCustomToken(this.node.credentials.uid, claims);
        app.delete();
        return token;
    }
    /**
     * Creates and initializes a callback to verify that the config node is in use.
     * Otherwise the connection with Firebase will be closed.
     * @note Use of a timer is essential because it's necessary to allow time for all nodes to start before checking
     * the number of nodes connected to this database.
     * @param removed A flag that indicates whether the node is being closed because it has been removed entirely,
     * or that it is just being restarted.
     * If `true`, execute the callback after 15s otherwise skip it.
     */
    destroyUnusedConnection(removed) {
        if (!removed || this.node.nodes.length > 0)
            return;
        this.destructionTimeouID = setTimeout(() => {
            this.node.warn(`WARNING: '${this.node.config.name}' config node is unused! The connection with Firebase will be closed.`);
            this.logOut()
                .then(() => this.node.log("Connection with Firebase was closed because no node used."))
                .catch((error) => this.node.error(error));
        }, 15000);
    }
    /**
     * Get credentials from JSON content of `config-node`.
     * @returns The JSON content credentials
     */
    getJSONCredential() {
        const content = JSON.parse(this.node.credentials.json || "{}");
        if (Object.keys(content).length === 0) {
            const projetId = this.node.credentials.url
                ?.split("https://")
                .pop()
                ?.split(/-default-rtdb\.((asia-southeast1|europe-west1)\.firebasedatabase\.app|firebaseio\.com)(\/)?$/)[0];
            const privateKey = JSON.stringify(this.node.credentials.privateKey)
                ?.replace(/\\\\n/gm, "\n")
                .replaceAll('"', "")
                .replaceAll("\\", "");
            content["projectId"] = projetId;
            content["clientEmail"] = this.node.credentials.clientEmail;
            content["privateKey"] = privateKey;
        }
        return this.checkJSONCredential(content);
    }
    /**
     * Creates and initializes a `@firebase/FirebaseApp` and `@firebase/Database` instance.
     */
    initApp() {
        this.node.app = (0, app_1.initializeApp)({
            apiKey: this.node.credentials.apiKey,
            databaseURL: this.node.credentials.url,
        }, this.node.id);
        this.node.auth = (0, auth_1.getAuth)(this.node.app);
        this.node.database = (0, database_1.getDatabase)(this.node.app);
    }
    /**
     * Creates and initializes a `@firebase-admin/FirebaseApp` and `@firebase-admin/Database` instance.
     */
    initAppWithSDK() {
        const content = this.getJSONCredential();
        this.node.app = firebase_admin_1.default.initializeApp({
            credential: firebase_admin_1.default.credential.cert(content),
            databaseURL: this.node.credentials.url,
        }, this.node.id);
        this.node.database = firebase_admin_1.default.database(this.node.app);
    }
    /**
     * Creates and initializes a listener to display the connection status with Firebase on nodes linked
     * to this database.
     */
    initConnectionStatus() {
        if (!this.node.database)
            return;
        this.subscriptionCallback = (0, database_1.onValue)((0, database_1.ref)(this.node.database, ".info/connected"), (snapshot) => {
            if (snapshot.val() === true) {
                // Clear timeout for setNodesDisconnected
                if (this.timeoutID) {
                    clearTimeout(this.timeoutID);
                    this.timeoutID = undefined;
                }
                this.setNodesConnected();
                this.node.RED.events.emit("Firebase:connected");
                this.node.log(`Connected to Firebase database: ${this.node.app?.options.databaseURL}`);
            }
            else {
                this.setNodesConnecting();
                this.node.RED.events.emit("Firebase:disconnect");
                // Based on maximum time for Firebase admin
                this.timeoutID = setTimeout(() => this.setNodesDisconnected(), 30000);
                this.node.log(`Connecting to Firebase database: ${this.node.app?.options.databaseURL}`);
            }
        }, (error) => this.node.error(error));
    }
    /**
     * Creates and initializes a logging to get warning message from bad database url configured and invalid credentials
     * in order to make it an error message.
     */
    initLogging() {
        // Works for both databases
        // Known Issue: how to know which module returned the log?
        if (!this.node.RED.events.eventNames().includes("Firebase:log"))
            (0, app_1.onLog)((log) => this.node.RED.events.emit("Firebase:log", log), { level: "warn" });
        this.node.RED.events.on("Firebase:log", this.onLog);
    }
    /**
     * This method checks if the database uses the `firebase-admin` module.
     * @param db The database used
     * @returns `true` if the database uses the `firebase-admin` module.
     */
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    isAdmin(db) {
        return this.node.config.authType === "privateKey";
    }
    /**
     * This method checks if the error is instance of FirebaseError.
     * @param error The error received
     * @returns `true` if the error is instance of FirebaseError
     */
    isFirebaseError(error) {
        return error instanceof app_1.FirebaseError || Object.prototype.hasOwnProperty.call(error, "code");
    }
    /**
     * Connects to Firebase with the authentication method defined in the `config-node`.
     * An event `Firebase:signedIn` will be triggered for Firebase connection completion.
     */
    logIn() {
        (async () => {
            try {
                // Initialize App
                this.admin ? this.initAppWithSDK() : this.initApp();
                // Initialize Logging
                this.initLogging();
                // Initialize Connection Status
                this.initConnectionStatus();
                // Log In
                switch (this.node.config.authType) {
                    case "anonymous":
                        await this.logInAnonymously();
                        break;
                    case "email":
                        await this.logInWithEmail();
                        break;
                    case "privateKey":
                        // Logged In with Initialize App
                        break;
                    case "customToken":
                        await this.logInWithCustomToken();
                        break;
                }
                this.node.signedIn = true;
                // Check if the config node is in use. Otherwise the connection with Firebase will be closed.
                this.destroyUnusedConnection(true);
            }
            catch (error) {
                this.node.signedIn = false;
                this.onError(error);
            }
            finally {
                this.node.RED.events.emit("Firebase:signedIn", this.node.signedIn);
            }
        })();
    }
    /**
     * Logs in as an anonymous user.
     * @returns A promise of signing completion
     */
    logInAnonymously() {
        if (!this.node.auth)
            return;
        return (0, auth_1.signInAnonymously)(this.node.auth);
    }
    /**
     * Logs in using a custom token containing a UID and optional additional Claims.
     * @returns A promise of signing completion
     */
    async logInWithCustomToken() {
        if (!this.node.auth)
            return;
        const token = await this.createCustomToken();
        return (0, auth_1.signInWithCustomToken)(this.node.auth, token);
    }
    /**
     * Logs in using an email and password.
     * @remarks An option allows to create or not a new user and will send a warning message when creating a new user.
     * @returns A promise of signing completion
     */
    async logInWithEmail() {
        if (!this.node.auth)
            return;
        // Checks if the user already has an account otherwise it creates one
        const method = await (0, auth_1.fetchSignInMethodsForEmail)(this.node.auth, this.node.credentials.email);
        if (method.length === 0 && this.node.config.createUser) {
            await (0, auth_1.createUserWithEmailAndPassword)(this.node.auth, this.node.credentials.email, this.node.credentials.password);
            this.node.warn(`The user "${this.node.credentials.email}" has been successfully created. You can delete it in the Authenticate section if it is an error.`);
        }
        else if (method.includes("password")) {
            await (0, auth_1.signInWithEmailAndPassword)(this.node.auth, this.node.credentials.email, this.node.credentials.password);
            // TODO: to see... else if (method.includes("link")) {}
        }
        else {
            throw new app_1.FirebaseError("auth/unknown-email", "");
        }
    }
    /**
     * Disconnects from Firebase.
     * @returns A promise for Firebase disconnection completion
     */
    async logOut() {
        if (!this.node.app)
            return;
        // If Node-RED is restarted, stop the timeout (avoid double logout request)
        clearTimeout(this.destructionTimeouID);
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.LOG_OUT;
        this.node.log(`Closing connection with Firebase database: ${this.node.app?.options.databaseURL}`);
        if (this.node.database && this.subscriptionCallback)
            this.subscriptionCallback();
        this.node.RED.events.removeListener("Firebase:log", this.onLog);
        await this.signOut();
        if (this.admin) {
            return firebase_admin_1.default.app(this.node.id).delete();
        }
        else {
            return (0, app_1.deleteApp)(this.node.app);
        }
    }
    /**
     * A custom method in case of error allowing to send a predefined error message if this error is known
     * otherwise returns the message as it is.
     * @param error The error received
     * @param done If defined this callback will return the error message
     */
    onError(error, done) {
        let msg = error.message || error.toString();
        if (this.isFirebaseError(error)) {
            msg = FirebaseError_1.firebaseError[error.code.split(".")[0]];
            // Not working for firebase-admin...
            if (error.code.match(/auth\/network-request-failed/)) {
                this.setNodesNoNetwork();
            }
            else if (error.code.startsWith("auth/")) {
                this.setNodesError(error.code.split("auth/").pop()?.split(".")[0].replace(/-/gm, " ").toPascalCase());
            }
            else {
                this.setNodesError();
            }
        }
        else {
            this.setNodesError();
        }
        msg = msg || error.message || error.toString();
        if (done)
            return done(msg);
        this.node.error(msg);
    }
    /**
     * Restores the connection with Firebase if at least one node is activated.
     * @remarks This method should only be used if the connection has been destroyed.
     */
    restoreDestroyedConnection() {
        if (this.node.nodes.length > 1)
            return;
        // If a node is started, stop the timeout
        clearTimeout(this.destructionTimeouID);
        this.destructionTimeouID = undefined;
        // Skip if Node-RED re-starts
        if (this.node.connectionStatus !== DatabaseNodeType_1.ConnectionStatus.LOG_OUT)
            return;
        this.logIn();
    }
    /**
     * Sets the status of nodes linked to this database as `Connected`.
     */
    setNodesConnected() {
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.CONNECTED;
        for (const node of this.node.nodes) {
            node.status({ fill: "green", shape: "dot", text: "Connected" });
        }
    }
    /**
     * Sets the status of nodes linked to this database as `Connecting`.
     */
    setNodesConnecting() {
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.CONNECTING;
        for (const node of this.node.nodes) {
            node.status({ fill: "yellow", shape: "ring", text: "Connecting" });
        }
    }
    /**
     * Sets the status of nodes linked to this database as `Disconnected`.
     */
    setNodesDisconnected() {
        if (this.node.connectionStatus === DatabaseNodeType_1.ConnectionStatus.ERROR)
            return;
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.DISCONNECTED;
        for (const node of this.node.nodes) {
            node.status({ fill: "red", shape: "dot", text: "Disconnected" });
        }
    }
    /**
     * Sets the status of nodes linked to this database as `Error`. An error code can also be set.
     * @param code The error code to add to the status
     */
    setNodesError(code) {
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.ERROR;
        for (const node of this.node.nodes) {
            node.status({ fill: "red", shape: "dot", text: `Error${code ? ": ".concat(code) : ""}` });
        }
    }
    /**
     * Sets the status of nodes linked to this database as `No Network`.
     */
    setNodesNoNetwork() {
        this.node.connectionStatus = DatabaseNodeType_1.ConnectionStatus.NO_NETWORK;
        for (const node of this.node.nodes) {
            node.status({ fill: "red", shape: "ring", text: "No Network" });
        }
    }
    /**
     * Signs out from Firebase.
     * @returns A promise for signout completion
     */
    signOut() {
        if (this.admin || !this.node.auth)
            return Promise.resolve();
        return (0, auth_1.signOut)(this.node.auth);
    }
}
exports.default = FirebaseDatabase;
